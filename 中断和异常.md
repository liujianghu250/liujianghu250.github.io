# 中断(Interrupt)和异常(Exception)
广义上的中断是指一个改变处理器执行的指令顺序的事件，实质上是CPU芯片内外部硬件电路产生的电信号。
中断又分为同步中断与异步中断两种。
- 同步中断，是当指令执行时由**CPU**控制单元产生的，只有在一条指令终止执行后CPU才会发出中断，也叫**异常**。
- 异步中断，是由**外部硬件设备**依照CPU时钟信号**随机**产生的，也就是狭义上的**中断**（以后提到的中断，如果没有特别说明，都是指这种狭义的中断）。

## 中断信号（包括中断与异常）的作用
中断信号能让处理器放下当前正常控制流，转而去执行其他代码。也就是说，当一个中断信号到达时，CPU必须停止它当前正在做的事情，并且切换到一个新的活动。

## 中断和异常的分类
中断分为可屏蔽中断与非屏蔽中断
### 可屏蔽中断
I/O设备发出的所有中断请求（IRQ）都产生可屏蔽中断。如果可屏蔽中断处于屏蔽状态时，控制单元忽略该中断
### 非屏蔽中断
只有几个危机事件（如硬件故障）才引起非屏蔽中断。非屏蔽中断总是由CPU辨认
异常可分为两大类，处理器探测异常（processor-detected exception）与编程异常（programmed exception），其中处理器探测异常又可以细分为3类，包括故障（fault）、陷阱（trap）、异常中止（abort）
### 处理器探测异常
CPU执行指令时探测到的一个反常条件所产生的异常。根据CPU控制单元产生异常时保存在内核堆栈eip寄存器中的值的不同可以分为三类
#### 故障（fault）
通常可以纠正，纠正后，程序将会重新执行那条引起故障的指令。比如缺页异常

#### 陷阱(trap)
陷阱指令执行后立即报告，但是内核处理完异常后不会重新执行已终止的指令。

#### 异常中止（abort）
发生了一个严重的错误。发生异常中止后，内核的控制权将被切换到相应的异常中止处理程序，而异常中止处理程序唯一的选择是强制终止受影响的进程。
### 编程异常
编程者发出请求时发出。一般是由int或int3指令触发的；当into（检查溢出）和bound（检查地址出界）指令检查条件不为真时，也引起编程异常。
控制单元将编程异常作为陷阱处理，也就是异常处理程序执行完毕后，不会重新执行引起异常的指令。
编程异常也叫**软中断**。
这种异常的用途主要有两种：
1. 执行系统调用
2. 给调试程序通报一个特定的事件

## 中断与异常的标识方法
每个中断异常都有0~255之间的一个数来标识，这个**8位无符号整数**叫做**向量**。
**非屏蔽中断**的向量和**异常**的向量都是**固定**的，而**可屏蔽中断**的向量可以通过对中断控制器的编程来改变。

# 中断
## IRQ与PIC
中断请求由硬件设备发出，最终由CPU处理，那么它是怎么传输的呢？CPU又是怎么知道它的向量呢？
答案是IRQ和PIC。
每个可以发出中断请求的硬件设备都有一条或多条叫**IRQ**（Interrupt ReQuest）**的输出线**。
所有现有的IRQ线都与一个名为**可编程中断控制器**（Programmable Interrupt Controller，PIC）的硬件电路的输入引脚相连。
硬件设备发出一个引发信号，通过IRQ传输给PIC；
而PIC根据IRQ线的编号（IRQ从0开始顺序编号，比如IRQ1,IRQ2……）选择优先级较高（编号越小，优先级越高）的信号，并且将接收到的信号转换成对应的向量（IRQn的缺省向量是n+32，但也可以通过对PIC进行编程进行修改）；
PIC将向量存放在自己的一个I/O端口，于是CPU就可以通过数据总线读取该向量；
将引发信号发送到处理器的INTR引脚，即产生一个中断；
CPU把这个中断信号写进PIC的一个I/O端口进行确认。
## APIC
# 异常
80x86微处理器发布了大约20种不同的异常，内核为每种异常提供一个异常处理程序，对于某些异常，CPU控制单元在开始执行异常处理程序前会产生一个硬件出错码，并且压入内核堆栈中。
## 常见异常
0 - Divide error (故障）
1 - Debug （陷阱或故障）
3 - Breakpoint（陷阱）
4 - Overflow（陷阱）
5 - Bound check（故障）
8 - Double fault（异常中止）
9 - Coprocessor segment overrun (异常中止）
11 - Segment not present（故障）
12 - Stack segment fault（故障）
13 - General protection（故障）
14 - Page fault （故障）
# 中断描述符表
中断描述符表是一个系统表，每一个中断或异常向量都有相应的中断或异常处理程序，而这些处理程序的入口地址就放在IDT中。
初始化IDT，就是内核的重要工作之一。
idtr寄存器中存放idt的线性基址及其限长。
idt是一个表，表中每一个项都是一个描述符，描述符有三种类型，描述符中40~43位的Type字段的值表示描述符的类型。
## 任务门描述符
存放一个TSS选择符。当中断信号发送时，内核会用任务门中的tss选择符对应的进程去取代当前进程。
## 中断门描述符
包含段选择符和中断或异常处理程序的段内偏移。当控制权转移到一个适当的段时，处理器清IF标志，从而关闭将来会发生的可屏蔽中断。
Linux利用中断门处理中断。
## 陷阱门描述符
与中断门相似，只是不修改IF标志。
Linux利用陷阱门处理异常。“Double fault”异常除外，它是唯一由任务门处理的异常。

# 中断与异常的硬件处理
假定内核已经被初始化（因此，CPU在保护模式下运行）
在执行一条新指令之前，CPU控制单元会检查在运行前一条指令时是否发生了中断或异常。如果发生了，那么控制单元执行以下操作：
1. 确定与中断或向量管理的向量i（0 <= i <= 255 ）；
2. 读idtr寄存器指向的IDT表中的第i项（假定是读取的表项是中断门或陷阱门）
3.从gdtr寄存器获得GDT的基址，并在GDT中查找，以读取IDT表项中的选择符所标识的段描述符。这个描述符指定中断或异常处理程序所在段的基地址。
4.检查权限。中断处理程序的特权不能低于引起中断的程序的特权，所以要比较当前特权级CPL（cs寄存器的低两位）与段描述符（存放在GDT中）的描述符特权级DPL，如果CPL比DPL小，就产生“General protection”异常。对于编程异常，还需要比较CPL与处于IDT中的门描述符的DPL，如果DOL小于CPL，就产生“General protection”异常，从而避免用户应用程序访问特殊的陷阱门或中断门。
5.检查是否发生特权级的变化。如果发生了变化，就需要使用与新的特权级相关的栈。
 - 读tr寄存器，以访问运行程序的TSS段
 - 用新特权级相关的栈段和栈指针的值（存在tss中）装载ss和esp寄存器
 - 在新的栈中保存ss和esp以前的值。




