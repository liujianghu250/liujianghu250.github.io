# 内存寻址
## 三种地址

## 分段与分页

## 页表初始化：内核页表，进程页表

硬件高速缓存

TLB

# 内存管理

RAM的某些部分永久分配给内核，并用来存放内核代码以及静态内核数据结构。
RAM的其余部分称为动态内存，需要时分配，不需要时释放。

## 页框管理
Linux采用4KB页框大小作为标准的内存分配单元。

### 页描述符
为了根据需要分配动态内存，内核必须能区分哪些页框包含的是属于**进程**的页，哪些包含的是**内核代码或内核数据**；内核还必须能确定动态内存中的页框**是否空闲**。

因此，内核必须记录每个页框当前的状态——使用**页描述符**。

页描述符的类型为struct page,所有的页描述符存放在mem_map数组中。

virt_to_page(addr)得到线性地址addr对应的页描述符地址。

`
#define virt_to_page(kaddr)	pfn_to_page(__pa(kaddr) >> PAGE_SHIFT)
`
__pa(kaddr)宏只能将固定映射到内核空间的线性地址转换成物理地址。

pfn_to_page(pfn)产生页框号pfn对应的页描述符地址。

#define page_to_pfn __page_to_pfn

__page_to_pfn这个宏的实现与内存管理模型有关。

比如flat memory model:访问物理内存的时候，物理地址空间是一个连续的，没有空洞的地址空间;
物理地址跟线性地址空间就有简单的线性映射关系，struct page数组mem_map中的每一项都可以对应某个具体的物理页面；

在这种模型下，

`
#define __pfn_to_page(pfn)	(mem_map + ((pfn) - ARCH_PFN_OFFSET))
`
ARCH_PFN_OFFSET 跟架构相关的物理起始地址的PFN，也就是physical_start_address>>PAGE_SHIFT。

## 内存管理模型
linux内存模型有三种：flat memory model，Discontiguous Memory Model，Sparse Memory Model。

分别由参数CONFIG_FLATMEM，CONFIG_DISCONTIGMEM，CONFIG_SPARSEMEM确定。

具体定义在include/asm-generic/memory-model.h中；

memory model针对的是物理内存的分布，主要涉及PFN跟page结构的转换。

### flat memory model

之前说过，flat memory model的物理地址空间是连续的。在这种模型中，页描述符和页框号的相互转换如下：

`
#define __pfn_to_page(pfn)	(mem_map + ((pfn) - ARCH_PFN_OFFSET))
#define __page_to_pfn(page)	((unsigned long)((page) - mem_map) + \
				 ARCH_PFN_OFFSET)
`

### Discontiguous Memory Model
而Discontiguous Memory Model不同，它的地址空间有一些空洞，是**不连续**的;Discontiguous Memory Model可以看做是flat memory model的扩展，单个连续的物理地址空间作为一个**node**，按flat memory model管理。

这是为了支持**非一致内存访问(Non-Uniform Memory Access , NUMA)模型**：在这种模型中，给定CPU对不同内存单元的访问时间可能不一样。

比如某些多处理器Alpha或MIPS计算机，就采用了非一致内存访问模型。（注意：NUMA模型是针对某一种体系结构的计算机而言的，而内存模型是针对内核。）

而在Discontiguous Memory Model中，系统的物理内存被划分为几个节点（node），划分的依据就是cpu访问这片内存的时间。

所以，在NUMA模型中，如果使用Discontiguous Memory Model，就可以将某个CPU最常引用的内核数据结构放到一个对它而言访问时间较少的节点中，从而达到减少访问内存所需时间的目的。

80x86体系结构使用的是一致访问内存(UMA)模型，所以它并不真正需要NUMA的支持。内核可以直接采用flat memory model。

但事实上，即便是flat memory model，Linux也使用了节点：一个包含系统中所有物理内存的节点。

这看起来是多此一举，其实不然：内核假定在所有的体系结构中物理内存都被划分为一个或多个节点，从而让内存代码的处理有了更好的可移植性。

(Linux对页表的处理也采用了类似的方法，即便硬件体系结构仅仅定义了两级页表，Linux也使用四级。）

### Sparse Memory Model

为了支持内存hotplug，引入了sparse memory model，热插拔导致了一个node上的内存可能都变得更加"稀疏";

更多关于内存模型的具体信息[这篇博客](https://blog.csdn.net/u014089131/article/details/53095985)

## 内存管理区
80x86 UMA体系结构中的内存分为3个管理区。

ZONE_DMA,包含低于16MB的内存页框

ZONE_NORMAL,包含高于16MB，低于896MB的内存页框

ZONE_HIHMEM，包含高于896MB的内存页框

管理区声明在include/linux/mmzone.h中。
为什么要分成这几个管理区?

因为计算机体系结构有硬件的制约，限制了页框可以使用的方式。

这三个管理区就是为了解决80x86的两种硬件制约。
1. ISA总线的直接内存存取（DMA）处理器只能对RAM的前16MB寻址。
2. 在具有大容量RAM的现代32位计算机中，CPU不能直接访问所有的物理内存。

ZONE_DMA包含的页框可以由老式基于ISA的设备通过DMA使用。

ZONE_DMA和ZONE_NORMAL包含内存的“常规”页框，内核在初始化时，会把它们线性得映射到线性地址空间的第4个GB，所以内核可以直接访问。

而ZONE_HIGHMEM包含的内存页不能由内核直接访问。

而对于64位体系结构，ZONE_HIGHMEM区总为空。（涉及高端内存的映射，后面再来解释）

而且x86_64还多了一个ZONE_DMA32,因为它支持32位地址总线的DMA内存空间。它的范围是低于4GB的内存空间。



