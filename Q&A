# 逻辑地址、虚拟地址、线性地址、物理地址的区别是什么？
答：
**逻辑地址**是编程时使用的地址，比如常用到的指针，指针内存的是某变量的地址，这个地址指的就是逻辑地址。
**物理地址**是用于内存芯片级的单元寻址，与处理器和CPU连接的地址总线相对应。
**虚拟地址**和**线性地址**是一个东西，都是指从逻辑地址转换到虚拟地址的中间的一个地址，只有在保护模式中才使用。因为它不是真实存在的地址，与物理地址相对应，所以叫虚拟地址，也因为它的地址空间是线性的，所以也叫线性地址。
（有时候好像也会用虚拟地址代指逻辑地址，还是尽量避免这种情况吧。）
## 实模式
在实模式中，逻辑地址=段基址+段内偏移，即段寄存器中存放段基址的高16位，段内偏移也只有16位。
物理地址 = 段寄存器内的值 * 10H + 偏移量
实模式下没有线性地址。

## 保护模式
保护模式下的转换相对比较复杂，简单总结如下：
逻辑地址通过分段机制转换成线性地址。
线性地址再通过分页机制转换成物理地址。
注意：Linxu对于分段机制只是简单使用，四个主要的代码段与数据段的基址都是0，限长都是4GB，所以线性地址的值其实和逻辑地址的偏移量的值是一致的。

# 为什么每个进程都需要有自己的页表，每个线程是否有自己的页表，每个内核线程呢？
## 为什么每个进程都需要有自己的页表？
每个进程都需要有自己的页表，因为每个进程的地址空间都应该是独立的，即不同进程间，大多数数据应该是独立的，不能互相访问的。
每个进程都拥有自己的页表，可以保证别的进程在一般情况下，是访问不到它的数据的，因为两个不同进程即便使用相同的线性地址，访问的也是各自的地址空间，指向的物理地址也一般不会相同。
可以思考这样一个问题，假如多个进程共同享有一个页表，如何保证彼此互不影响呢？
在每个页表项上标注该页的拥有者(某一个进程）也许是一个解决办法，就像linux里的文件一样，但是这样一来，开销就太大了，在空间上，需要存储进程的id，在时间上，每次访问页时都需要对页的拥有者进行验证……
由此可以看出，独立的页表，或者说独立的地址空间，对于作为资源分配的单位的进程来说，是相当必要的。
## 每个线程是否有自己的页表？
要回答这个问题，先要明白线程的含义与作用，以及线程与进程的区别。
进程是分配系统资源（CPU时间、内存等）的实体。
而一个进程，可能由多个线程组成。每个线程负责进程的一小部分工作。
举个例子，在电脑上打开qq，这就是一个进程。如果在qq中同时打开多个聊天窗口，那么每个聊天窗口就是一个线程。
每个线程拥有一些独立的资源，但大部分资源，都是和其他所有线程，也就是整个进程共享的。
而对于内存资源来说，最好最简单的共享方法，无疑就是共享同一个地址空间，也就是说，共享页表。
对于线程来说，它的独立性没有进程那么强，反而有大量需要和其他进程共享的内存资源，所以，线程不需要有自己的页表。

## 内核线程是否有自己的页表？
上面提到的线程，其实是**用户线程**。
还有一种线程，叫**内核线程**，负责刷新磁盘高速缓存，交换不用的页框，维护网络连接等任务。
内核线程只运行在内核态，而普通进程既可以运行在内核态，也可以运行在用户态。
也正因为内核线程只运行在内核态，所以用户空间对它而言没有意义，它只使用内核空间，也就是大于PAGE_OFFSET的线性地址空间。
这也就意味着，它完全不需要拥有自己的页表——使用**内核页表**就够了。
### 内核页表
内核维持着一组自己使用的页表，驻留在所谓的主内核页全局目录中。主内核页全局目录的最高目录项部分作为参考模型，位系统中每个普通进程对于的页全局目录项提供参考模型。
内核会确保对主内核页全局目录的修改能传递到由进程使用的页全局目录中。

# 进程切换（换入、换出）时是如何保留自己的页表的？
从本质上来讲，每个进程切换由两步组成。
1. 切换页全局目录以安装一个新的地址空间；
2. 切换内核态堆栈和硬件上下文，因为硬件上下文提供了内核执行新进程所需要的所有信息，包括CPU寄存器。
保留页表，无疑是发生在第一步。
那么这一步是如何实现的呢？
首先认识一个寄存器，cr3控制寄存器，它存放的是正在使用的页目录的物理地址。
所以切换当前页目录表，也就是改变cr3寄存器的值，具体操作如下：
Linux把cr3控制寄存器的内容保存在**前一个执行进程的描述符**中，然后把**下一个要执行进程的描述符**的值装入cr3寄存器中。
也就是说，进程切换时，进程保留自己的页表的方法，是将页目录表的物理地址，存到进程的描述符中。
在2.6.11中，进程描述符都是task_struct类型结构，其中有一个字段是指向内存区描述符结构的指针，struct mm_struct *mm;
而struct mm_struct中有指向页目录表的指针pgd_t * pgd;
## cr3中是页目录表的物理地址，而指针是逻辑地址，是怎么实现相互转换的呢？
首先看看创建新进程时，内核是如何为新进程分配页全局目录的。
也就是看看pgd_alloc()函数的具体实现：
`
static inline pgd_t *pgd_alloc(struct mm_struct *mm)
{
	unsigned boundary;
	pgd_t *pgd = (pgd_t *)__get_free_page(GFP_KERNEL|__GFP_REPEAT);
	if (!pgd)
		return NULL;
	/*
	 * Copy kernel pointers in from init.
	 * Could keep a freelist or slab cache of those because the kernel
	 * part never changes.
	 */
	boundary = pgd_index(__PAGE_OFFSET);
	memset(pgd, 0, boundary * sizeof(pgd_t));
	memcpy(pgd + boundary,
	       init_level4_pgt + boundary,
	       (PTRS_PER_PGD - boundary) * sizeof(pgd_t));
	return pgd;
}
`
重点应该是__get_free_page，但是暂时没看懂，后面再来看。

# X86_32的虚拟地址空间是如何分布的？X86_64的虚拟地址空间是如何分布的？
## X86_32的虚拟地址空间分布

# 不同页表的两个页表项可以指向同一个页吗？ 
可以。
内核通过页描述符记录每个物理页的信息，描述符中有一个字段是atomic_t _count，页的引用计数器。
该字段为-1，说明相应物理页空闲，可以被分配给任一进程或内核本身；如果该字段**大于或等于0**，则说明页框被分配给了**一个或多个进程**，或者用于存放一些内核数据结构。
由上面的描述就可以看出，同一个物理页，是有可能被分配给多个进程的。
比如共享内存。

# x86：32位、PAE、64位，分别的页表组织是怎样？
## 32位
RAM为4GB，线性地址32位，物理地址也是32位，cr3寄存器中存放页目录表的物理地址。
### 页目录项中PS=0，页大小为4KB时。
根据cr3控制寄存器找到页目录表，每个页目录表项4字节，最多1024项。
线性地址最高10位是Directory字段，即页目录表的索引，根据该字段可以找到一个具体的页目录表项（2^10 = 1024）。
页目录表项中存放着页表的基址，可以找到一个具体页表。
线性地址中间10位是Table字段，是页表的索引，根据该字段可以找到一个具体的页表项。
页表项结构与页目录表项相同，里面存放一个物理页的基址。
线性地址最低12位是Offset字段，是页内偏移，由此可以找到具体某一个字节的物理地址。
线性地址分级为10+10+12

### PS = 1,页大小为4MB
cr3指向页目录表。
线性地址最高10位指向页目录表1024个项中的一个，每个项都指向一个物理页。
线性地址低22位作为页内偏移，找到一个字节的物理地址。
线性地址分级为10+22

## PAE
RAM为64GB，线性地址32位，但物理地址36位，cr3寄存器存放页目录指针表（PDPT）的基地址。
一个页目录指针表中，有4个64位表项。
### PS=0，即页大小为4KB时。
cr3指向一个PDPT
线性地址最高两位（31-30）指向PDPT4个项中的一个。每个项都指向一个页目录表。
64GB的RAM被分成2^24个物理页，页表项的物理地址字段从20位扩展到了24位，再加上12个标志位，32位的页表项已经满足不了需求。为了对齐方便访问，所以每个页表项大小从32位变成了64位。
页目录表中页目录表项的数目也从1024变成了512。
线性地址的位（29-21），9位，指向页目录表中的512个项中的一个，而每一个项都指向一个页表。
线性地址位20-12，9位，指向页表中512个项中的一个，而每一个项都指向一个物理页。
线性地址位11-0,12位，作为页内偏移，最终找到一个字节的物理地址。
线性地址分级为2+9+9+12

### PS=1,页大小为2MB
cr3指向一个PDPT
位31-30指向PDPT中4个项中的一个
位29-21指向页目录中512个项中的一个
位20-0，2MB页中的偏移量

线性地址分级为2+9+21

## 64位
4级分页。
采用页全局目录，页上级目录，页中间目录，页表，具体实现与32位类似。
页大小为4KB，寻址使用48位，线性地址分级为 9+9+9+9+12。
高16位被用作符号扩展，这高16位要么全是0，要么全是1。



# x86架构下的内存为什么分为ZONE_DMA、ZONE_DMA32、ZONE_NORMAL、ZONE_HIGH？ X86_64下包含哪些Zone类型？
## x86架构下的内存为什么分为ZONE_DMA、ZONE_DMA32、ZONE_NORMAL、ZONE_HIGH？
因为80x86架构有两种硬件约束：
1. ISA总线的直接内存存取（DMA）处理器有一个严格的限制：它们只能对RAM的前16MB寻址；
2. 在具有大容量RAM的现代32位计算机中，CPU不能直接访问所有物理内存。以Linux为例，在初始化阶段，内核只把896MB的RAM窗口映射到内核线性地址空间，如果一个程序需要对现有RAM的其他部分寻址，那就必须把某些其他线性地址间隔映射到所需的RAM。。
因为第一种限制，低于16MB的内存被称为ZONE_DMA,单独作为一个管理区。该区包含的页框可以由老式基于ISA的设备通过DMA使用。
在x86_64架构下，还需要ZONE_DMA32，因为需要32位地址寻址的DMA.这部分是高于16MB，低于4GB。
因为第二种限制，高于896MB的内存页框被称为ZONE_HIGHMEM,不能由内核直接访问。64位体系结构上ZONE_HIGHMEM总是为空。
剩余的部分，即高于16MB，低于896MB的部分，被称为ZONE_NORMAL,内核可以直接进行访问，但不能通过DMA使用。

## X86_64下包含哪些Zone类型？
和x86相比，多了ZONE_DMA32，少了ZONE_HIGHMEM。
0-16MB，是ZONE_DMA
16MB-4GB，是ZONE_DMA32
4GB以上，是ZONE_NORMAL

# 伙伴系统算法的原理？

# 释放一个page到伙伴系统后，这个page需要跟旁边的空闲page合并成更大的块，那么是跟左边的合并 还是跟右边的合并呢？ 
