关键在于页全局目录。


# 所有进程的内核低端内存的页表是同一份吗？

是。

主内核页全局目录的最高项部分作为参考模型，为系统中每个进程对应的页全局目录项提供参考模型。

也就是说，低端内存部分对应的页全局目录项，在所有进程中都是相同的。
而页全局目录项中存的是页上级目录的物理地址。
页全局目录项相同，就意味着页上级目录的物理地址相同。
访问的是同一个页上级目录，如果依次访问下去，页中间目录，页表，页，自然也就都相同。


总结：在不同的进程中，只有页全局目录的地址不同，但直接映射到内核地址空间的线性地址对应的页目录表项相同。所以相应的页上级目录，页中间目录，页表，都是同一份。

# 所有固定映射都不会改变页全局目录项，这一点和直接映射一样。

# 永久映射，利用的是一个不变的页全局目录项，所以也是一样的。

# 只有非连续内存区有些不同，它可能会改变页全局目录的表项。所以就有可能会导致缺页。

非连续内存区分配和释放空间时，都是只对主内核页表进行操作，不涉及进程的页表。

就有可能出现以下两种情况：
## 一、分配时
1.	内核分配了一个新的非连续内存区，并修改了主内核页全局目录的表项。
2.	在此之后，一个内核态的进程访问该部分区域的某一个线性地址，但是它自己的进程页表的页全局目录中相应的项为空，由此发生了缺页异常。
3.	缺页异常处理程序会检查主内核页表，看能不能找到相应的页，如果可以，就同步进程页表。如果找不到，就说明可能是其他错误。

## 二、释放时
内核释放了一个非连续内存区，但没有通知进程，会不会导致错误的访问？

不会。
因为内核释放非连续内存区时，只会清除页表项，但不会收回页表所在的页，所以页中间目录项，页上级目录项，乃至页全局目录项，都不会发生改变。

 假设一个进程对已释放的非连续内存区进行寻址。
1. 它要么从未修改过页全局目录项，完全不知道内核曾经分配然后又释放过一个非连续内存区，即页全局目录项就为空，所以会发生缺页异常。
2. 要么它修改过页全局目录项，于是就按照这个页全局目录项去寻址，最终寻找到的是其实就是主内核页表同一份的页表，然后它会发现这是一个空的页表项，从而触发缺页异常。
两种情况下，缺页异常处理程序都会检查主内核页表，如果没找到有效的表项，说明这是一个错误的访问。
