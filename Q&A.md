## 逻辑地址、虚拟地址、线性地址、物理地址的区别是什么？
答：
**逻辑地址**是编程时使用的地址，比如常用到的指针，指针内存的是某变量的地址，这个地址指的就是逻辑地址。
**物理地址**是用于内存芯片级的单元寻址，与处理器和CPU连接的地址总线相对应。
**虚拟地址**和**线性地址**是一个东西，都是指从逻辑地址转换到虚拟地址的中间的一个地址，只有在保护模式中才使用。因为它不是真实存在的地址，与物理地址相对应，所以叫虚拟地址，也因为它的地址空间是线性的，所以也叫线性地址。
（有时候好像也会用虚拟地址代指逻辑地址，还是尽量避免这种情况吧。）
### 实模式
在实模式中，逻辑地址=段基址+段内偏移，即段寄存器中存放段基址的高16位，段内偏移也只有16位。
物理地址 = 段寄存器内的值 * 10H + 偏移量
实模式下没有线性地址。

### 保护模式
保护模式下的转换相对比较复杂，简单总结如下：
逻辑地址通过分段机制转换成线性地址。
线性地址再通过分页机制转换成物理地址。
注意：Linxu对于分段机制只是简单使用，四个主要的代码段与数据段的基址都是0，限长都是4GB，所以线性地址的值其实和逻辑地址的偏移量的值是一致的。

## 为什么每个进程都需要有自己的页表，每个线程是否有自己的页表，每个内核线程呢？
### 为什么每个进程都需要有自己的页表？
每个进程都需要有自己的页表，因为每个进程的地址空间都应该是独立的，即不同进程间，大多数数据应该是独立的，不能互相访问的。
每个进程都拥有自己的页表，可以保证别的进程在一般情况下，是访问不到它的数据的，因为两个不同进程即便使用相同的线性地址，访问的也是各自的地址空间，指向的物理地址也一般不会相同。
可以思考这样一个问题，假如多个进程共同享有一个页表，如何保证彼此互不影响呢？
在每个页表项上标注该页的拥有者(某一个进程）也许是一个解决办法，就像linux里的文件一样，但是这样一来，开销就太大了，在空间上，需要存储进程的id，在时间上，每次访问页时都需要对页的拥有者进行验证……
由此可以看出，独立的页表，或者说独立的地址空间，对于作为资源分配的单位的进程来说，是相当必要的。
### 每个线程是否有自己的页表？
要回答这个问题，先要明白线程的含义与作用，以及线程与进程的区别。
进程是分配系统资源（CPU时间、内存等）的实体。
而一个进程，可能由多个线程组成。每个线程负责进程的一小部分工作。
举个例子，在电脑上打开qq，这就是一个进程。如果在qq中同时打开多个聊天窗口，那么每个聊天窗口就是一个线程。
每个线程拥有一些独立的资源，但大部分资源，都是和其他所有线程，也就是整个进程共享的。
而对于内存资源来说，最好最简单的共享方法，无疑就是共享同一个地址空间，也就是说，共享页表。
对于线程来说，它的独立性没有进程那么强，反而有大量需要和其他进程共享的内存资源，所以，线程不需要有自己的页表。

### 内核线程是否有自己的页表？
上面提到的线程，其实是**用户线程**。
还有一种线程，叫**内核线程**，负责刷新磁盘高速缓存，交换不用的页框，维护网络连接等任务。
内核线程只运行在内核态，而普通进程既可以运行在内核态，也可以运行在用户态。
也正因为内核线程只运行在内核态，所以用户空间对它而言没有意义，它只使用内核空间，也就是大于PAGE_OFFSET的线性地址空间。
这也就意味着，它完全不需要拥有自己的页表——使用**内核页表**就够了。
#### 内核页表
内核维持着一组自己使用的页表，驻留在所谓的主内核页全局目录中。主内核页全局目录的最高目录项部分作为参考模型，位系统中每个普通进程对于的页全局目录项提供参考模型。
内核会确保对主内核页全局目录的修改能传递到由进程使用的页全局目录中。

## 进程切换（换入、换出）时是如何保留自己的页表的？
从本质上来讲，每个进程切换由两步组成。
1. 切换页全局目录以安装一个新的地址空间；
2. 切换内核态堆栈和硬件上下文，因为硬件上下文提供了内核执行新进程所需要的所有信息，包括CPU寄存器。
保留页表，无疑是发生在第一步。
那么这一步是如何实现的呢？
首先认识一个寄存器，cr3控制寄存器，它存放的是正在使用的页目录的物理地址。
所以切换当前页目录表，也就是改变cr3寄存器的值，具体操作如下：
Linux把cr3控制寄存器的内容保存在**前一个执行进程的描述符**中，然后把**下一个要执行进程的描述符**的值装入cr3寄存器中。
也就是说，进程切换时，进程保留自己的页表的方法，是将页目录表的物理地址，存到进程的描述符中。
在2.6.11中，进程描述符都是task_struct类型结构，其中有一个字段是指向内存区描述符结构的指针，struct mm_struct *mm;
而struct mm_struct中有指向页目录表的指针pgd_t * pgd;
### cr3中是页目录表的物理地址，而指针是逻辑地址，是怎么实现相互转换的呢？
首先看看创建新进程时，内核是如何为新进程分配页全局目录的。
也就是看看pgd_alloc()函数的具体实现：
`
static inline pgd_t *pgd_alloc(struct mm_struct *mm)
{
	unsigned boundary;
	pgd_t *pgd = (pgd_t *)__get_free_page(GFP_KERNEL|__GFP_REPEAT);
	if (!pgd)
		return NULL;
	/*
	 * Copy kernel pointers in from init.
	 * Could keep a freelist or slab cache of those because the kernel
	 * part never changes.
	 */
	boundary = pgd_index(__PAGE_OFFSET);
	memset(pgd, 0, boundary * sizeof(pgd_t));
	memcpy(pgd + boundary,
	       init_level4_pgt + boundary,
	       (PTRS_PER_PGD - boundary) * sizeof(pgd_t));
	return pgd;
}
`

重点应该是__get_free_page，但是暂时没看懂，后面再来看。

## X86_32的虚拟地址空间是如何分布的？X86_64的虚拟地址空间是如何分布的？
### X86_32的虚拟地址空间分布

## 不同页表的两个页表项可以指向同一个页吗？ 
可以。
内核通过页描述符记录每个物理页的信息，描述符中有一个字段是atomic_t _count，页的引用计数器。
该字段为-1，说明相应物理页空闲，可以被分配给任一进程或内核本身；如果该字段**大于或等于0**，则说明页框被分配给了**一个或多个进程**，或者用于存放一些内核数据结构。
由上面的描述就可以看出，同一个物理页，是有可能被分配给多个进程的。
比如共享内存。

## x86：32位、PAE、64位，分别的页表组织是怎样？
### 32位
RAM为4GB，线性地址32位，物理地址也是32位，cr3寄存器中存放页目录表的物理地址。
#### 页目录项中PS=0，页大小为4KB时。
根据cr3控制寄存器找到页目录表，每个页目录表项4字节，最多1024项。
线性地址最高10位是Directory字段，即页目录表的索引，根据该字段可以找到一个具体的页目录表项（2^10 = 1024）。
页目录表项中存放着页表的基址，可以找到一个具体页表。
线性地址中间10位是Table字段，是页表的索引，根据该字段可以找到一个具体的页表项。
页表项结构与页目录表项相同，里面存放一个物理页的基址。
线性地址最低12位是Offset字段，是页内偏移，由此可以找到具体某一个字节的物理地址。
线性地址分级为10+10+12

#### PS = 1,页大小为4MB
cr3指向页目录表。
线性地址最高10位指向页目录表1024个项中的一个，每个项都指向一个物理页。
线性地址低22位作为页内偏移，找到一个字节的物理地址。
线性地址分级为10+22

### PAE
RAM为64GB，线性地址32位，但物理地址36位，cr3寄存器存放页目录指针表（PDPT）的基地址。
一个页目录指针表中，有4个64位表项。
#### PS=0，即页大小为4KB时。
cr3指向一个PDPT
线性地址最高两位（31-30）指向PDPT4个项中的一个。每个项都指向一个页目录表。
64GB的RAM被分成2^24个物理页，页表项的物理地址字段从20位扩展到了24位，再加上12个标志位，32位的页表项已经满足不了需求。为了对齐方便访问，所以每个页表项大小从32位变成了64位。
页目录表中页目录表项的数目也从1024变成了512。
线性地址的位（29-21），9位，指向页目录表中的512个项中的一个，而每一个项都指向一个页表。
线性地址位20-12，9位，指向页表中512个项中的一个，而每一个项都指向一个物理页。
线性地址位11-0,12位，作为页内偏移，最终找到一个字节的物理地址。
线性地址分级为2+9+9+12

#### PS=1,页大小为2MB
cr3指向一个PDPT
位31-30指向PDPT中4个项中的一个
位29-21指向页目录中512个项中的一个
位20-0，2MB页中的偏移量

线性地址分级为2+9+21

### 64位
4级分页。
采用页全局目录，页上级目录，页中间目录，页表，具体实现与32位类似。
页大小为4KB，寻址使用48位，线性地址分级为 9+9+9+9+12。
高16位被用作符号扩展，这高16位要么全是0，要么全是1。



## x86架构下的内存为什么分为ZONE_DMA、ZONE_DMA32、ZONE_NORMAL、ZONE_HIGH？ X86_64下包含哪些Zone类型？
### x86架构下的内存为什么分为ZONE_DMA、ZONE_DMA32、ZONE_NORMAL、ZONE_HIGH？
因为80x86架构有两种硬件约束：
1. ISA总线的直接内存存取（DMA）处理器有一个严格的限制：它们只能对RAM的前16MB寻址；
2. 在具有大容量RAM的现代32位计算机中，CPU不能直接访问所有物理内存。以Linux为例，在初始化阶段，内核只把896MB的RAM窗口映射到内核线性地址空间，如果一个程序需要对现有RAM的其他部分寻址，那就必须把某些其他线性地址间隔映射到所需的RAM。。
因为第一种限制，低于16MB的内存被称为ZONE_DMA,单独作为一个管理区。该区包含的页框可以由老式基于ISA的设备通过DMA使用。
在x86_64架构下，还需要ZONE_DMA32，因为需要32位地址寻址的DMA.这部分是高于16MB，低于4GB。
因为第二种限制，高于896MB的内存页框被称为ZONE_HIGHMEM,不能由内核直接访问。64位体系结构上ZONE_HIGHMEM总是为空。
剩余的部分，即高于16MB，低于896MB的部分，被称为ZONE_NORMAL,内核可以直接进行访问，但不能通过DMA使用。

### X86_64下包含哪些Zone类型？
和x86相比，多了ZONE_DMA32，少了ZONE_HIGHMEM。
0-16MB，是ZONE_DMA
16MB-4GB，是ZONE_DMA32
4GB以上，是ZONE_NORMAL

## 伙伴系统算法的原理？
 将所有空闲页框分组成11个块链表，每个块链表的节点分别是1,2,4,8,16,32,64,128,256,512,1024个连续的页框。
当需要分配内存时，去寻找最小的，可以满足条件的块。
比如要请求分配一个250个页框的内存。
1.去256个页框的链表中寻找，如果有空闲的块，就将它分配给请求内存的进程。
3. 如果没有空闲的块，就去寻找下一个更大的页块，即512个页框的块。如果有空闲块，就将该块分成两等份，一半分配给进程，另一半插入到256个页框的链表中。
4.如果512个页框的链表中也没有空闲块，也去寻找下一个更大的页块，即1024个页框的块。如果有，就先将该页框两等分，其中一半插入512个页框的链表中，另一半再次二等分，一半插入256个页框的链表中，另一半分配给进程。
5.如果1024个页框的链表中也没有空闲块，就放弃分配内存并发出出错信号。

而释放过程就是以上过程的逆过程，在释放后悔试图把一对空闲伙伴块合并。
伙伴算法可以尽可能避免外部碎片的产生，因为剩下的所有空闲块，最小也是1个页框，完全可以分配给需要的内存。
而合并操作也保证了连续空间尽可能大。
但它会导致内部碎片。

## 释放一个page到伙伴系统后，这个page需要跟旁边的空闲page合并成更大的块，那么是跟左边的合并 还是跟右边的合并呢？ 
答案取决于块的地址。
在伙伴系统中，对于伙伴的定义如下：
 1. 两个块具有相同的大小，记作b
 2. 它们的物理地址是连续的
 3. 第一个块的第一个页框的物理地址是 2 x b x 2^12的倍数。
 
第三个条件是为了保证内存对齐，也是必须满足的条件。
所以，如果释放的page，也可以扩大范围到包含b个页框的块（对于单独的一页，b就为1），它的第一个页框物理地址是2 x b x 2^12的倍数，那它就和右边（地址比它大）的块合并，否则，就和左边的块合并。

## pthread_create()和fork()有什么区别？ 
pthread_creat()和fork()都是用户态的API，但作用不同。一个是创建线程，一个是创建进程。
它们调用的系统调用也不同，一个调用了clone（），一个调用了fork()。
这两个系统调用的服务例程自然也不相同，一个是sys_clone(),一个是sys_fork(),但两个服务例程都调用了do_fork()函数。
`
asmlinkage long sys_fork(struct pt_regs *regs)
{
	return do_fork(SIGCHLD, regs->rsp, regs, 0, NULL, NULL);
}

asmlinkage long sys_clone(unsigned long clone_flags, unsigned long newsp, void __user *parent_tid, void __user *child_tid, struct pt_regs *regs)
{
	if (!newsp)
		newsp = regs->rsp;
	return do_fork(clone_flags, newsp, regs, 0, parent_tid, child_tid);
}
`
## IDT表是如何被初始化的？
### IDT的第一次初始化
当计算机还运行在实模式时，IDT被初始化并由BIOS例程使用。这部分由BIOS负责，暂时不深入了解。
### IDT的在内核中的初始化
在arch\x86\boot\main.c的main()函数中，最后一句是调用go_to_protected_mod();也就是从实模式离开，进入保护模式。
而在go_to_protected_mod()中，有一句setup_idt();
`

static void setup_idt(void)
{
	static const struct gdt_ptr null_idt = {0, 0};
	asm volatile("lidtl %0" : : "m" (null_idt));//l 代表32位，初始化idt寄存器
}

struct gdt_ptr {
	u16 len;
	u32 ptr;
} __attribute__((packed));

`
可以看出，该函数对idt进行了初始化，但长度和地址都是0。
而在arch\x86\kern\kernel\machine_kexec_64.c中，另外有一个set_idt()函数，被machine_kexec（）调用，而且限长与物理地址同样是0。去看了看则几个函数的调用层次。
set_idt() <- machine_kexec（）<- kernel_kexec（）<- SYSCALL_DEFINE4，然后发现SYSCALL_DEFINE4只被用于reboot。
也就是说，boot和reboot对idtr的初始化都是长度为0，地址也为0。



`
//将curidt中的值加载到中断描述符表格寄存器 (IDTR)。
static void set_idt(void *newidt, u16 limit)
{
	struct desc_ptr curidt;

	/* x86-64 supports unaliged loads & stores */
	curidt.size    = limit;
	curidt.address = (unsigned long)newidt;

	__asm__ __volatile__ (
		"lidtq %0\n"
		: : "m" (curidt)
		);
	//q可能是指64位。
};
`

#### 预初始化
一旦Linux接管，IDT就被转移到RAM的另一个区域，并进行第二次初始化。
首先用setup_idt()函数用同一个中断门（即指向ignore_int()中断处理程序）来填充所有256个idt表项。
ignore_int()处理程序可以看作一个空的处理程序，除了保存寄存器、恢复寄存器，执行iret恢复被中断的程序以外，只调用printk（）函数打印“Unknown iterrupt”系统消息。
ignore_int()应该从不执行，除非是出现了硬件问题（一个I/O设备正在产生没有预料到的中断）或内核问题（一个中断或异常没有被适当地处理）。

### 用有意义的陷阱和中断处理程序替换ignore_int()。
一旦这个过程完成，对控制单元产生的每个不同的异常，IDT都有一个专门的陷阱或系统门，而对于可编程中断控制器确认的每一个IRQ，IDT都将包括一个专门的中断门。
使用set_intr_gate（）插入用户程序无法访问的中断门，set_system_gate（）插入系统门
set_system_intr_gate（）插入系统中断门，set_trap_gate（）插入陷阱门……
各种门的分类，有机会再了解
## 说一下内核处理中断的完整过程？
确定向量，读idt表，找到中断处理程序，保存与装载寄存器值，跳转到中断处理程序，中断处理完成后，控制权转交给被中断的进程。
执行中断处理程序时，Linux中，紧随中断要执行的操作有三类：
1. 禁止可屏蔽中断后执行的操作，要在一个中断处理程序中立即执行，如对PIC应答中断，对PIC或设备控制器编程，或者修改由设备和处理器同时访问的数据结构。
2. 开中断情况下，需要很快完成的操作。如，修改只有处理器才会访问的数据结构。
3. 可以被延迟较长的时间间隔，由独立的函数执行的操作，如把缓冲区的内容拷贝到某个进程的地址空间。


### I/O中断
在PCI总线的体系结构中，几个设备可以共享同一个IRQ线，而一个中断向量是对应一个IRQ线，而不是设备。
所以仅仅中断向量无法说明所有问题，I/O中断处理程序必须足够灵活以给多个设备同时提供服务。
中断处理程序的灵活性是以两种不同的方式实现的。
#### IRQ共享
中断处理程序执行多个中断服务例程（ISR）。每个ISR是一个与单独设备（共享IRQ线）相关的函数，因为不可能预先知道是哪个特定的设备产生IRQ，所以，每个ISR都被执行，以验证它的设备是否需要关注。如果是，当设备产生中断时，就执行需要执行的所有操作。

#### IRQ动态分配
一条IRQ线在可能的最后时刻才与一个设备驱动程序相关联，例如，软盘设备的IRQ线只有在用户访问软盘设备时才被分配。

### 处理器间中断

### 时钟中断
## 网卡的中断服务程序正在执行过程中会被新的网卡中断打断吗？
## Linux支持哪些中断下半部，它们的区别是什么？ 
## 对/proc/interrupts和/proc/softirqs进行解读
## 什么是内核抢占？系统中有哪些内核抢占的时机？ 
## Linux内核有哪些同步机制？他们的区别是什么？哪些同步机制可以用于中断处理函数？
## 获得自旋锁后可以发生内核抢占么？为什么？
## 内核是如何维持墙钟和单调时钟的？系统睡眠唤醒对单调时钟是否有影响？设置系统时间对单调时钟是 否有影响？ Linux中的高精度定时器和低精度定时器分别是如何组织的？ malloc()分配的物理内存是连续的吗，kmalloc()呢，为什么？
## 缺页异常处理的过程是怎样的？ 
## echo m > /proc/sysrq-trigger可以将内存信息比较详细的输出到dmesg中，请解读 ps可以看到内核线程的内存使用都是0，为什么？
## top命令中看到的CPU核在各种状态的百分比是如何计算出来的？
## gdb -p process_A_pid 跟踪上进程A后可以修改进程A中变量的值，它是如何做到的？ 
## 系统调用的流程是怎样的？
## x86上有哪些系统调用的方式？当前x86_64使用的是哪种系统调用方式？ 
## 主流的N路组相连的CPU cache是怎么回事？
## X86的CPU有哪些主要的cache？哪些是socket共享的，哪些是core共享的？
 

